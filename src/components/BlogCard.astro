---
interface Props {
  post: {
    id: string;
    title: string;
    slug: string;
    excerpt: string;
    coverImage?: string | null;
    date: string;
    category: string;
    tags: string[];
    readTime: string;
  };
  featured?: boolean;
  index?: number;
}

const { post, featured = false, index = 0 } = Astro.props;

// Base path for GitHub Pages deployment
const basePath = '/astro-blog-2026/';

const formatDate = (dateString: string) => {
  const date = new Date(dateString);
  return date.toLocaleDateString('zh-CN', {
    year: 'numeric',
    month: 'short',
    day: 'numeric'
  });
};

const formatReadTime = (readTime: string) => {
  return readTime.replace('min', '分钟');
};

// Staggered animation delay based on index
const staggerDelay = index * 80;
---

<article
  class:list={[
    'blog-card group relative',
    featured ? 'md:col-span-2 md:row-span-2' : ''
  ]}
  data-tilt
  data-magnetic
  style={`--stagger-delay: ${staggerDelay}ms`}
>
  <a href={`${basePath}blog/${post.slug}`} class="card-inner block h-full">
    <!-- Animated glow border with conic gradient -->
    <div class="glow-border"></div>
    
    <!-- Spotlight glow that follows cursor -->
    <div class="glow-spotlight"></div>
    
    <!-- Shine sweep effect -->
    <div class="shine-effect"></div>
    
    <div class="card-body relative h-full bg-white dark:bg-gray-900 rounded-2xl overflow-hidden border border-gray-200 dark:border-gray-800 group-hover:border-primary-500/30 transition-all duration-500 shadow-lg group-hover:shadow-2xl group-hover:shadow-primary-500/10">
      <!-- Cover Image -->
      {post.coverImage ? (
        <div class:list={['image-container relative overflow-hidden', featured ? 'aspect-[21/9]' : 'aspect-video']}>
          <img
            src={post.coverImage}
            alt={post.title}
            class="card-image w-full h-full object-cover will-change-transform"
            loading="lazy"
          />
          <div class="absolute inset-0 bg-gradient-to-t from-gray-900/80 via-gray-900/20 to-transparent"></div>
          
          <!-- Category badge with slide-in -->
          <div class="badge-wrapper absolute top-4 left-4 z-10">
            <span class="inline-flex items-center gap-1.5 px-3 py-1.5 rounded-full bg-white/95 dark:bg-gray-900/95 backdrop-blur-md text-xs font-semibold text-gray-900 dark:text-white border border-white/30 shadow-lg shadow-black/10">
              <span class="w-1.5 h-1.5 rounded-full bg-primary-500 animate-pulse"></span>
              {post.category}
            </span>
          </div>
          
          <!-- Hover gradient overlay -->
          <div class="image-overlay absolute inset-0 bg-gradient-to-t from-primary-600/30 via-transparent to-transparent"></div>
        </div>
      ) : (
        <div class:list={['relative bg-gradient-to-br from-primary-100 to-accent-100 dark:from-primary-900/30 dark:to-accent-900/30', featured ? 'aspect-[21/9]' : 'aspect-video']}>
          <div class="absolute inset-0 flex items-center justify-center">
            <svg class="w-16 h-16 text-primary-300 dark:text-primary-700" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M19.5 14.25v-2.625a3.375 3.375 0 00-3.375-3.375h-1.5A1.125 1.125 0 0113.5 7.125v-1.5a3.375 3.375 0 00-3.375-3.375H8.25m0 12.75h7.5m-7.5 3H12M10.5 2.25H5.625c-.621 0-1.125.504-1.125 1.125v17.25c0 .621.504 1.125 1.125 1.125h12.75c.621 0 1.125-.504 1.125-1.125V11.25a9 9 0 00-9-9z" />
            </svg>
          </div>
          
          <div class="badge-wrapper absolute top-4 left-4 z-10">
            <span class="inline-flex items-center gap-1.5 px-3 py-1.5 rounded-full bg-white/95 dark:bg-gray-900/95 backdrop-blur-md text-xs font-semibold text-gray-900 dark:text-white">
              <span class="w-1.5 h-1.5 rounded-full bg-primary-500 animate-pulse"></span>
              {post.category}
            </span>
          </div>
        </div>
      )}
      
      <!-- Content with enhanced slide-up animation -->
      <div class:list={['card-content p-6', featured ? 'md:p-8' : '']}>
        <h3 class:list={[
          'card-title font-bold text-gray-900 dark:text-white mb-3 line-clamp-2',
          featured ? 'text-2xl md:text-3xl' : 'text-lg'
        ]}>
          {post.title}
        </h3>
        
        <p class:list={[
          'card-excerpt text-gray-600 dark:text-gray-400 mb-4 line-clamp-2',
          featured ? 'text-base' : 'text-sm'
        ]}>
          {post.excerpt}
        </p>
        
        <!-- Meta info -->
        <div class="card-meta flex items-center justify-between text-sm text-gray-500 dark:text-gray-500">
          <div class="flex items-center gap-3">
            <time datetime={post.date} class="flex items-center gap-1.5">
              <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z" />
              </svg>
              {formatDate(post.date)}
            </time>
            <span class="flex items-center gap-1.5">
              <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
              </svg>
              {formatReadTime(post.readTime)}
            </span>
          </div>
          
          <!-- Arrow icon with bounce animation -->
          <span class="arrow-icon w-9 h-9 rounded-full bg-gray-100 dark:bg-gray-800 flex items-center justify-center">
            <svg class="w-4 h-4 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
            </svg>
          </span>
        </div>
        
        <!-- Tags with staggered animation -->
        {post.tags.length > 0 && (
          <div class="card-tags flex flex-wrap gap-2 mt-4 pt-4 border-t border-gray-100 dark:border-gray-800">
            {post.tags.slice(0, 3).map((tag, i) => (
              <span 
                class="tag-item inline-flex items-center px-2.5 py-1 rounded-full text-xs font-medium bg-gray-100 dark:bg-gray-800 text-gray-600 dark:text-gray-400"
                style={`--tag-delay: ${i * 60}ms`}
              >
                #{tag}
              </span>
            ))}
          </div>
        )}
      </div>
    </div>
  </a>
</article>

<style>
  /* ===== Entrance Animation ===== */
  .blog-card {
    perspective: 1200px;
    transform-style: preserve-3d;
    animation: cardEntrance 0.7s cubic-bezier(0.16, 1, 0.3, 1) backwards;
    animation-delay: var(--stagger-delay, 0ms);
  }

  @keyframes cardEntrance {
    from {
      opacity: 0;
      transform: translateY(40px) scale(0.92) rotateX(-5deg);
    }
    to {
      opacity: 1;
      transform: translateY(0) scale(1) rotateX(0);
    }
  }

  /* ===== Card Inner - 3D Transform Container ===== */
  .card-inner {
    display: block;
    height: 100%;
    transform-style: preserve-3d;
    will-change: transform;
  }

  /* ===== Animated Glow Border with Conic Gradient ===== */
  .glow-border {
    position: absolute;
    inset: -2px;
    border-radius: 1.1rem;
    background: conic-gradient(
      from var(--glow-angle, 0deg),
      theme('colors.primary.400'),
      theme('colors.accent.400'),
      theme('colors.primary.400'),
      theme('colors.accent.400'),
      theme('colors.primary.400')
    );
    opacity: 0;
    filter: blur(10px);
    transition: opacity 0.5s ease;
    z-index: -1;
  }

  .blog-card:hover .glow-border {
    opacity: 0.8;
    animation: glowRotate 3s linear infinite;
  }

  @keyframes glowRotate {
    from { --glow-angle: 0deg; }
    to { --glow-angle: 360deg; }
  }

  @property --glow-angle {
    syntax: '<angle>';
    initial-value: 0deg;
    inherits: false;
  }

  /* ===== Spotlight Effect ===== */
  .glow-spotlight {
    position: absolute;
    inset: 0;
    border-radius: 1rem;
    background: radial-gradient(
      500px circle at var(--mouse-x, 50%) var(--mouse-y, 50%),
      rgba(255, 255, 255, 0.12),
      transparent 40%
    );
    opacity: 0;
    transition: opacity 0.4s ease;
    pointer-events: none;
    z-index: 2;
  }

  :global(.dark) .glow-spotlight {
    background: radial-gradient(
      500px circle at var(--mouse-x, 50%) var(--mouse-y, 50%),
      rgba(129, 140, 248, 0.15),
      transparent 40%
    );
  }

  .blog-card:hover .glow-spotlight {
    opacity: 1;
  }

  /* ===== Shine Sweep Effect ===== */
  .shine-effect {
    position: absolute;
    inset: 0;
    border-radius: 1rem;
    background: linear-gradient(
      105deg,
      transparent 40%,
      rgba(255, 255, 255, 0.08) 45%,
      rgba(255, 255, 255, 0.15) 50%,
      rgba(255, 255, 255, 0.08) 55%,
      transparent 60%
    );
    background-size: 200% 100%;
    background-position-x: 180%;
    opacity: 0;
    pointer-events: none;
    z-index: 3;
    transition: opacity 0.4s ease;
  }

  .blog-card:hover .shine-effect {
    opacity: 1;
    animation: shineSweep 1.2s ease-out forwards;
  }

  @keyframes shineSweep {
    to { background-position-x: -80%; }
  }

  /* ===== Card Body ===== */
  .card-body {
    transition: border-color 0.5s ease, box-shadow 0.5s ease;
    box-shadow: 
      0 4px 6px -1px rgb(0 0 0 / 0.07),
      0 2px 4px -2px rgb(0 0 0 / 0.05);
  }

  .blog-card:hover .card-body {
    border-color: transparent;
    box-shadow: 
      0 30px 60px -15px rgb(0 0 0 / 0.2),
      0 0 0 1px rgba(255, 255, 255, 0.05);
  }

  /* ===== Image Container & Enhanced Zoom ===== */
  .image-container {
    overflow: hidden;
  }

  .card-image {
    transition: transform 0.7s cubic-bezier(0.16, 1, 0.3, 1);
    will-change: transform;
    transform-origin: center center;
  }

  .blog-card:hover .card-image {
    transform: scale(1.1);
  }

  /* Image overlay */
  .image-overlay {
    opacity: 0;
    transition: opacity 0.5s ease;
  }

  .blog-card:hover .image-overlay {
    opacity: 1;
  }

  /* ===== Badge Animation ===== */
  .badge-wrapper {
    transform: translateY(8px);
    opacity: 0.8;
    transition: transform 0.4s cubic-bezier(0.16, 1, 0.3, 1),
                opacity 0.4s ease;
  }

  .blog-card:hover .badge-wrapper {
    transform: translateY(0);
    opacity: 1;
  }

  /* ===== Content Slide-up Animation ===== */
  .card-content {
    transform: translateZ(30px);
  }

  .card-title {
    transform: translateY(0);
    transition: transform 0.4s cubic-bezier(0.16, 1, 0.3, 1),
                color 0.3s ease;
  }

  .blog-card:hover .card-title {
    transform: translateY(-3px);
    color: theme('colors.primary.600');
  }

  :global(.dark) .blog-card:hover .card-title {
    color: theme('colors.primary.400');
  }

  .card-excerpt {
    transform: translateY(0);
    opacity: 0.85;
    transition: transform 0.4s cubic-bezier(0.16, 1, 0.3, 1) 0.03s,
                opacity 0.4s ease 0.03s;
  }

  .blog-card:hover .card-excerpt {
    transform: translateY(-3px);
    opacity: 1;
  }

  .card-meta {
    transform: translateY(0);
    opacity: 0.85;
    transition: transform 0.4s cubic-bezier(0.16, 1, 0.3, 1) 0.06s,
                opacity 0.4s ease 0.06s;
  }

  .blog-card:hover .card-meta {
    transform: translateY(-3px);
    opacity: 1;
  }

  /* ===== Arrow Animation ===== */
  .arrow-icon {
    transition: background-color 0.3s ease, transform 0.3s cubic-bezier(0.16, 1, 0.3, 1);
  }

  .arrow-icon svg {
    transition: transform 0.3s cubic-bezier(0.16, 1, 0.3, 1), color 0.3s ease;
  }

  .blog-card:hover .arrow-icon {
    background-color: theme('colors.primary.100');
    transform: scale(1.1);
  }

  :global(.dark) .blog-card:hover .arrow-icon {
    background-color: rgba(99, 102, 241, 0.2);
  }

  .blog-card:hover .arrow-icon svg {
    transform: translateX(3px);
    color: theme('colors.primary.600');
  }

  :global(.dark) .blog-card:hover .arrow-icon svg {
    color: theme('colors.primary.400');
  }

  /* ===== Tags Staggered Animation ===== */
  .card-tags {
    transform: translateY(0);
    opacity: 0.85;
    transition: transform 0.4s cubic-bezier(0.16, 1, 0.3, 1) 0.09s,
                opacity 0.4s ease 0.09s;
  }

  .blog-card:hover .card-tags {
    transform: translateY(-3px);
    opacity: 1;
  }

  .tag-item {
    transform: translateY(0);
    transition: transform 0.35s cubic-bezier(0.16, 1, 0.3, 1),
                background-color 0.3s ease,
                color 0.3s ease;
    transition-delay: var(--tag-delay, 0ms);
  }

  .blog-card:hover .tag-item {
    transform: translateY(-2px);
    background-color: theme('colors.primary.50');
    color: theme('colors.primary.600');
  }

  :global(.dark) .blog-card:hover .tag-item {
    background-color: rgba(99, 102, 241, 0.15);
    color: theme('colors.primary.400');
  }

  /* ===== Reduced Motion ===== */
  @media (prefers-reduced-motion: reduce) {
    .blog-card,
    .card-inner,
    .glow-border,
    .glow-spotlight,
    .shine-effect,
    .card-body,
    .card-image,
    .image-overlay,
    .badge-wrapper,
    .card-title,
    .card-excerpt,
    .card-meta,
    .arrow-icon,
    .arrow-icon svg,
    .card-tags,
    .tag-item {
      animation: none !important;
      transition: none !important;
      transform: none !important;
    }
  }
</style>

<script>
  // ===== Enhanced 3D Tilt with Smooth Easing & Magnetic Effect =====
  class CardEffects {
    private card: HTMLElement;
    private inner: HTMLElement;
    private spotlight: HTMLElement | null;
    
    // Tilt state
    private currentRotateX = 0;
    private currentRotateY = 0;
    private targetRotateX = 0;
    private targetRotateY = 0;
    
    // Magnetic state
    private currentX = 0;
    private currentY = 0;
    private targetX = 0;
    private targetY = 0;
    
    private rafId: number | null = null;
    private isHovering = false;
    private rect: DOMRect | null = null;
    
    // Configuration
    private readonly maxTilt = 10;
    private readonly magneticStrength = 0.08;
    private readonly magneticRadius = 150;
    private readonly lerpFactor = 0.1;

    constructor(card: HTMLElement) {
      this.card = card;
      this.inner = card.querySelector('.card-inner') as HTMLElement;
      this.spotlight = card.querySelector('.glow-spotlight');
      
      if (!this.inner) return;
      
      this.bindEvents();
    }

    private bindEvents() {
      // Mouse events for tilt
      this.card.addEventListener('mouseenter', this.onMouseEnter.bind(this));
      this.card.addEventListener('mousemove', this.onMouseMove.bind(this));
      this.card.addEventListener('mouseleave', this.onMouseLeave.bind(this));
      
      // Global mouse move for magnetic effect (works outside card bounds)
      document.addEventListener('mousemove', this.onGlobalMouseMove.bind(this));
    }

    private onMouseEnter() {
      this.isHovering = true;
      this.rect = this.card.getBoundingClientRect();
      this.startAnimation();
    }

    private onMouseMove(e: MouseEvent) {
      if (!this.rect) {
        this.rect = this.card.getBoundingClientRect();
      }
      
      const x = e.clientX - this.rect.left;
      const y = e.clientY - this.rect.top;
      const centerX = this.rect.width / 2;
      const centerY = this.rect.height / 2;
      
      // Calculate tilt with smooth falloff at edges
      const normalizedX = x / this.rect.width;
      const normalizedY = y / this.rect.height;
      
      // Apply easing curve for more natural movement
      const easeX = this.easeOutQuad(normalizedX * 2 - 1);
      const easeY = this.easeOutQuad(normalizedY * 2 - 1);
      
      this.targetRotateX = easeY * -this.maxTilt;
      this.targetRotateY = easeX * this.maxTilt;
      
      // Update spotlight position
      if (this.spotlight) {
        const percentX = (x / this.rect.width) * 100;
        const percentY = (y / this.rect.height) * 100;
        this.spotlight.style.setProperty('--mouse-x', `${percentX}%`);
        this.spotlight.style.setProperty('--mouse-y', `${percentY}%`);
      }
    }

    private onGlobalMouseMove(e: MouseEvent) {
      if (!this.rect) {
        this.rect = this.card.getBoundingClientRect();
      }
      
      const centerX = this.rect.left + this.rect.width / 2;
      const centerY = this.rect.top + this.rect.height / 2;
      
      const deltaX = e.clientX - centerX;
      const deltaY = e.clientY - centerY;
      const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
      
      if (distance < this.magneticRadius) {
        // Magnetic pull strength decreases with distance
        const force = Math.pow(1 - distance / this.magneticRadius, 2);
        this.targetX = deltaX * this.magneticStrength * force;
        this.targetY = deltaY * this.magneticStrength * force;
      } else {
        this.targetX = 0;
        this.targetY = 0;
      }
    }

    private onMouseLeave() {
      this.isHovering = false;
      this.targetRotateX = 0;
      this.targetRotateY = 0;
      this.targetX = 0;
      this.targetY = 0;
    }

    private easeOutQuad(t: number): number {
      return t < 0 ? -(1 - Math.pow(-t, 2)) : 1 - Math.pow(1 - t, 2);
    }

    private startAnimation() {
      if (this.rafId) return;
      
      const animate = () => {
        // Smooth interpolation (lerp)
        this.currentRotateX += (this.targetRotateX - this.currentRotateX) * this.lerpFactor;
        this.currentRotateY += (this.targetRotateY - this.currentRotateY) * this.lerpFactor;
        this.currentX += (this.targetX - this.currentX) * this.lerpFactor;
        this.currentY += (this.targetY - this.currentY) * this.lerpFactor;
        
        // Apply combined transforms
        this.inner.style.transform = `
          translateX(${this.currentX}px)
          translateY(${this.currentY}px)
          rotateX(${this.currentRotateX}deg)
          rotateY(${this.currentRotateY}deg)
        `;
        
        // Continue animation while values are changing
        const threshold = 0.01;
        const needsAnimation = 
          this.isHovering ||
          Math.abs(this.currentRotateX) > threshold ||
          Math.abs(this.currentRotateY) > threshold ||
          Math.abs(this.currentX) > threshold ||
          Math.abs(this.currentY) > threshold;
        
        if (needsAnimation) {
          this.rafId = requestAnimationFrame(animate);
        } else {
          this.rafId = null;
        }
      };
      
      this.rafId = requestAnimationFrame(animate);
    }

    destroy() {
      if (this.rafId) {
        cancelAnimationFrame(this.rafId);
        this.rafId = null;
      }
    }
  }

  // ===== Initialize Effects =====
  const cardInstances: CardEffects[] = [];

  function initCardEffects() {
    // Clean up existing instances
    cardInstances.forEach(instance => instance.destroy());
    cardInstances.length = 0;
    
    // Create new instances
    document.querySelectorAll('[data-tilt]').forEach((card) => {
      cardInstances.push(new CardEffects(card as HTMLElement));
    });
  }

  // Run on initial load
  initCardEffects();

  // Re-run on view transitions (Astro)
  document.addEventListener('astro:page-load', initCardEffects);
</script>
